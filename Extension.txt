#My solution for extension is that extend some new grammars base on existing grammars.
Here you find below extension:    

<OPERATION_FUNC> ::= "(" OPERATION <LIST>|<VAR>  <LIST>|<VAR> ")" 
OPERATION ::= "PLUS" | "MINUS" | "MUL" | "DIV" | "MOD" | "ABS" 
<LISTFUNC> ::= "CAT" <VAR> | <LIST>   <VAR> | <LIST>
<IOFUNC>  ::= "RESET" <VAR> | "SWAP" <VAR> <VAR> 
<BOOLFUNC> ::= ATOM <LIST>


1. Just simply make all can run my extension as they have been extended in previous functions, so I can build as less extra functions as I could. 

2.Extend the operation function to a more variety of operation.
#MUL stands for multiple, DIV stands for division , MOD stands for modulus, ABS stands for absolute value.
#Only Atomic lisp can do operation
#For division, parser will not check if divider is 0 ,on the contrary, interpreter will check  

3.Extend list function can do variable swap their values and status
#e.g (SET A '1') (SWAP A B) -- after swapping, A will be undefined and swap its value to B which B become has been defined

4.Also, listfunction can do CAT (concatenation)
#e.g (CAT A '(1 3)') -- after "catting", '(1 3)' will be immediately concatenated to A , as A's new cdr

5.IO function adds a reset function which can reset the variable has been defined
# (RESET A) -- A will be reset whatever previous value it was to default(which is 0)
# Only variable can be reset

6.Bool function can do isatomic function by using "ATOM"
#e.g (IF (ATOM B)) | (WHILE (ATOM NIL)) -- in this examples, I try to check if B/"NIL" is atomic lisp 
